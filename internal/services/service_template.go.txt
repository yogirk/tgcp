package template_service

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/table"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/yogirk/tgcp/internal/core"
	"github.com/yogirk/tgcp/internal/ui/components"
	"github.com/yogirk/tgcp/internal/styles"
)

const CacheTTL = 30 * time.Second

// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------

// ExampleItem represents a resource managed by this service
type ExampleItem struct {
	Name   string
	Status string
	ID     string
}

// Tick message for background refresh
type tickMsg time.Time

// ViewState defines the current UI state of the service
type ViewState int

const (
	ViewList ViewState = iota
	ViewDetail
	ViewConfirmation
)

// Msg types
type dataMsg []ExampleItem
type errMsg error
type actionResultMsg struct{ err error }

// -----------------------------------------------------------------------------
// Service Definition
// -----------------------------------------------------------------------------

// Service implements the services.Service interface
type Service struct {
	client    *Client // Your API Client
	projectID string
	table     *components.StandardTable

	// UI Components
	filter components.FilterModel

	// State
	items     []ExampleItem
	loading   bool
	err       error

	// View State
	viewState    ViewState
	selectedItem *ExampleItem

	// Confirmation State
	pendingAction string    // e.g. "start", "stop"
	actionSource  ViewState // Where to return after confirmation

	// Cache
	cache *core.Cache
}

// NewService creates a new instance of the service
func NewService(cache *core.Cache) *Service {
	// 1. Table Setup
	columns := []table.Column{
		{Title: "Name", Width: 30},
		{Title: "Status", Width: 15},
		{Title: "ID", Width: 20},
	}

	t := components.NewStandardTable(columns)

	return &Service{
		table:     t,
		filter:     components.NewFilterWithPlaceholder("Filter items..."),
		viewState: ViewList,
		cache:     cache,
	}
}

// Name returns the full human-readable name
func (s *Service) Name() string {
	return "Template Service"
}

// ShortName returns the specialized identifier (e.g. "gce", "sql")
func (s *Service) ShortName() string {
	return "template"
}

// HelpText returns context-aware keybindings
func (s *Service) HelpText() string {
	if s.viewState == ViewList {
		return "r:Refresh  /:Filter  Ent:Detail"
	}
	if s.viewState == ViewDetail {
		return "Esc/q:Back"
	}
	if s.viewState == ViewConfirmation {
		return "y:Confirm  n:Cancel"
	}
	return ""
}

// -----------------------------------------------------------------------------
// Lifecycle & Interface Implementation
// -----------------------------------------------------------------------------

// InitService initializes the API client
func (s *Service) InitService(ctx context.Context, projectID string) error {
	s.projectID = projectID
	// Initialize your client here
	// client, err := NewClient(ctx)
	// if err != nil { return err }
	// s.client = client
	return nil
}

// Reinit reinitializes the service with a new project ID
func (s *Service) Reinit(ctx context.Context, projectID string) error {
	s.Reset()
	return s.InitService(ctx, projectID)
}

// Init startup commands (e.g. background tick)
func (s *Service) Init() tea.Cmd {
	return s.tick()
}

// tick creates a background ticker for cache invalidation
func (s *Service) tick() tea.Cmd {
	return tea.Tick(CacheTTL, func(t time.Time) tea.Msg {
		return tickMsg(t)
	})
}

// Refresh triggers a forced data reload
func (s *Service) Refresh() tea.Cmd {
	s.loading = true
	return s.fetchDataCmd(true)
}

// Reset clears the service state when navigating away or switching projects
func (s *Service) Reset() {
	s.viewState = ViewList
	s.selectedItem = nil
	s.err = nil          // CRITICAL: Always clear errors on reset
	s.table.SetCursor(0) // Reset table position
	s.filter.ExitFilterMode()
}

// IsRootView returns true if we are at the top-level list
func (s *Service) IsRootView() bool {
	return s.viewState == ViewList
}

// Focus handles input focus (Visual Highlight)
func (s *Service) Focus() {
	s.table.Focus()
}

// Blur handles loss of input focus (Visual Dimming)
func (s *Service) Blur() {
	s.table.Blur()
}

// -----------------------------------------------------------------------------
// Update Loop
// -----------------------------------------------------------------------------

func (s *Service) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	// 1. Background Tick
	case tickMsg:
		return s, tea.Batch(s.fetchDataCmd(false), s.tick())

	// 2. Data Loaded
	case dataMsg:
		s.loading = false
		s.items = msg
		s.updateTable(s.items)
		return s, func() tea.Msg { return core.LastUpdatedMsg(time.Now()) }

	// 3. Error Handling
	case errMsg:
		s.loading = false
		s.err = msg

	case actionResultMsg:
		if msg.err != nil {
			s.err = msg.err
		}
		// Refresh after action
		return s, s.Refresh()

	// 4. Window Resize
	case tea.WindowSizeMsg:
		s.table.HandleWindowSizeDefault(msg)

	// 5. User Input
	case tea.KeyMsg:
		// OPTION 1: Modern Filter Pattern (Recommended)
		// Use HandleFilterUpdate for cleaner, more maintainable filter handling
		if s.viewState == ViewList {
			result := components.HandleFilterUpdate(
				&s.filter,
				msg,
				s.items,
				func(items []ExampleItem, query string) []ExampleItem {
					return s.getFilteredItems(items, query)
				},
				s.updateTable,
			)

			if result.Handled {
				if result.Cmd != nil {
					return s, result.Cmd
				}
				if !result.ShouldContinue {
					return s, nil
				}
				// Continue processing other keys
			}
		}

		// OPTION 2: Manual Filter Handling (Alternative)
		// Use this if you need more control over filter behavior
		// Uncomment below and comment out Option 1 if needed:
		/*
		wasActive := s.filter.IsActive()
		shouldExit, shouldKeepValue, filterCmd := s.filter.HandleKeyMsg(msg)
		
		if filterCmd != nil && !wasActive {
			return s, filterCmd
		}
		
		if shouldExit {
			if !shouldKeepValue {
				s.updateTable(s.items)
			}
		} else if s.filter.IsActive() {
			items := s.getCurrentItems()
			s.updateTable(items)
			return s, filterCmd
		}
		*/

		// LIST VIEW KEYBINDINGS
		if s.viewState == ViewList {
			switch msg.String() {
			case "r":
				return s, s.Refresh()
			case "enter":
				// Handle selection
				items := s.getCurrentItems()
				if idx := s.table.Cursor(); idx >= 0 && idx < len(items) {
					s.selectedItem = &items[idx]
					s.viewState = ViewDetail
				}
			}
			var updatedTable *components.StandardTable
			updatedTable, cmd = s.table.Update(msg)
			s.table = updatedTable
			return s, cmd
		}

		// DETAIL VIEW KEYBINDINGS
		if s.viewState == ViewDetail {
			switch msg.String() {
			case "esc", "q":
				s.viewState = ViewList
				s.selectedItem = nil
				return s, nil
			// Add action keys here
			}
		}

		// CONFIRMATION VIEW KEYBINDINGS
		if s.viewState == ViewConfirmation {
			switch msg.String() {
			case "y", "enter":
				// Perform Action
				// cmd = s.performActionCmd()
				s.viewState = s.actionSource
				s.pendingAction = ""
				return s, cmd
			case "n", "esc", "q":
				s.viewState = s.actionSource
				s.pendingAction = ""
				return s, nil
			}
		}
	}

	return s, nil
}

// -----------------------------------------------------------------------------
// View Rendering
// -----------------------------------------------------------------------------

func (s *Service) View() string {
	if s.loading && len(s.items) == 0 {
		return components.RenderSpinner("Loading...")
	}
	if s.err != nil {
		return components.RenderError(s.err, s.Name(), "Items")
	}

	if s.viewState == ViewDetail {
		return s.renderDetailView()
	}
	if s.viewState == ViewConfirmation {
		// Use shared confirmation component
		// Example: components.RenderConfirmation(s.pendingAction, s.selectedItem.Name, "item")
		return components.RenderConfirmation(s.pendingAction, s.selectedItem.Name, "item")
	}

	// Default: List View
	return s.renderListView()
}

func (s *Service) renderListView() string {
	return s.table.View()
}

// -----------------------------------------------------------------------------
// Helper Commands
// -----------------------------------------------------------------------------

func (s *Service) fetchDataCmd(force bool) tea.Cmd {
	return func() tea.Msg {
		key := "template_data"

		// 1. Check Cache
		if !force && s.cache != nil {
			if val, found := s.cache.Get(key); found {
				if items, ok := val.([]ExampleItem); ok {
					return dataMsg(items)
				}
			}
		}

		// 2. API Call (Simulated)
		// if s.client == nil { return errMsg(fmt.Errorf("client not init")) }
		// data, err := s.client.ListItems()
		// if err != nil { return errMsg(err) }
		data := []ExampleItem{} // Placeholder

		// 3. Update Cache
		if s.cache != nil {
			s.cache.Set(key, data, CacheTTL)
		}

		return dataMsg(data)
	}
}

func (s *Service) updateTable(items []ExampleItem) {
	rows := make([]table.Row, len(items))
	for i, item := range items {
		rows[i] = table.Row{item.Name, item.Status, item.ID}
	}
	s.table.SetRows(rows)
}

// getCurrentItems returns the currently visible items (filtered if filter is active)
func (s *Service) getCurrentItems() []ExampleItem {
	query := s.filter.Value()
	if query == "" {
		return s.items
	}
	return components.FilterSlice(s.items, query, func(item ExampleItem, q string) bool {
		return components.ContainsMatch(item.Name, item.Status, item.ID)(q)
	})
}

// getFilteredItems is used by HandleFilterUpdate - filters items based on query
func (s *Service) getFilteredItems(items []ExampleItem, query string) []ExampleItem {
	if query == "" {
		return items
	}
	return components.FilterSlice(items, query, func(item ExampleItem, q string) bool {
		return components.ContainsMatch(item.Name, item.Status, item.ID)(q)
	})
}

// renderDetailView renders the detail view for a selected item
// Example implementation:
func (s *Service) renderDetailView() string {
	if s.selectedItem == nil {
		return "Error: No item selected"
	}

	// Use lipgloss for styling
	title := styles.TitleStyle.Render(s.selectedItem.Name)
	
	// Build detail content
	var content strings.Builder
	content.WriteString(title + "\n\n")
	content.WriteString(fmt.Sprintf("Status: %s\n", s.selectedItem.Status))
	content.WriteString(fmt.Sprintf("ID: %s\n", s.selectedItem.ID))
	
	// Wrap in a styled box
	return styles.BoxStyle.Copy().
		Border(lipgloss.RoundedBorder()).
		Padding(1, 2).
		Width(60).
		Render(content.String())
}

// performActionCmd is an example of how to implement action commands
// Example: Start/Stop actions
func (s *Service) performActionCmd(action string) tea.Cmd {
	return func() tea.Msg {
		if s.client == nil {
			return errMsg(fmt.Errorf("client not initialized"))
		}
		
		// Example: Perform API call
		// err := s.client.PerformAction(s.selectedItem.ID, action)
		// if err != nil {
		//     return actionResultMsg{err: err}
		// }
		
		// Return success (no error)
		return actionResultMsg{err: nil}
	}
}

// Example: Multiple tables pattern (like GCS service)
// If your service needs multiple tables (e.g., buckets and objects):
/*
type Service struct {
	// ... other fields ...
	table      *components.StandardTable  // Main table
	objectTable *components.StandardTable // Secondary table
}

func (s *Service) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		s.table.HandleWindowSizeDefault(msg)
		s.objectTable.HandleWindowSizeDefault(msg) // Handle both tables
	// ... rest of update logic
	}
}
*/

// getFilteredItems is used by HandleFilterUpdate - filters items based on query
func (s *Service) getFilteredItems(items []ExampleItem, query string) []ExampleItem {
	if query == "" {
		return items
	}
	return components.FilterSlice(items, query, func(item ExampleItem, q string) bool {
		return components.ContainsMatch(item.Name, item.Status, item.ID)(q)
	})
}

// renderDetailView renders the detail view for a selected item
// Example implementation:
func (s *Service) renderDetailView() string {
	if s.selectedItem == nil {
		return "Error: No item selected"
	}

	// Use lipgloss for styling
	title := styles.TitleStyle.Render(s.selectedItem.Name)
	
	// Build detail content
	var content strings.Builder
	content.WriteString(title + "\n\n")
	content.WriteString(fmt.Sprintf("Status: %s\n", s.selectedItem.Status))
	content.WriteString(fmt.Sprintf("ID: %s\n", s.selectedItem.ID))
	
	// Wrap in a styled box
	return styles.BoxStyle.Copy().
		Border(lipgloss.RoundedBorder()).
		Padding(1, 2).
		Width(60).
		Render(content.String())
}

// performActionCmd is an example of how to implement action commands
// Example: Start/Stop actions
func (s *Service) performActionCmd(action string) tea.Cmd {
	return func() tea.Msg {
		if s.client == nil {
			return errMsg(fmt.Errorf("client not initialized"))
		}
		
		// Example: Perform API call
		// err := s.client.PerformAction(s.selectedItem.ID, action)
		// if err != nil {
		//     return actionResultMsg{err: err}
		// }
		
		// Return success (no error)
		return actionResultMsg{err: nil}
	}
}

// Example: Multiple tables pattern (like GCS service)
// If your service needs multiple tables (e.g., buckets and objects):
/*
type Service struct {
	// ... other fields ...
	table      *components.StandardTable  // Main table
	objectTable *components.StandardTable // Secondary table
}

func (s *Service) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		s.table.HandleWindowSizeDefault(msg)
		s.objectTable.HandleWindowSizeDefault(msg) // Handle both tables
	// ... rest of update logic
	}
}
*/
