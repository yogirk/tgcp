// =============================================================================
// SERVICE TEMPLATE - Copy this file to create a new GCP service
// =============================================================================
//
// REGISTRATION CHECKLIST (all 4 required):
// -----------------------------------------
// 1. Register in internal/ui/model.go → registerAllServices()
//    registry.Register("myservice", func(cache *core.Cache) services.Service {
//        return myservice.NewService(cache)
//    })
//
// 2. Add to internal/ui/components/home_menu.go → NewHomeMenu() Categories
//    - Find the appropriate category (Compute, Storage, Databases, Data & Analytics, Security & Networking, Observability)
//    - Add ServiceItem with Name (display name) and ShortName (must match registry key)
//    - Example: {Name: "My Service", ShortName: "myservice"}
//
// 3. Add to internal/ui/components/sidebar.go → Items list
//    - Maintain category order (see groupBreaks map for category positions)
//    - Use Unicode symbol for Icon (NOT emoji) - see docs/DEVELOPER_GUIDE.md "Icon Guidelines"
//    - Example: {Name: "My Service", ShortName: "myservice", Icon: "◆"}
//
// 4. Update groupBreaks map in sidebar.go if adding to a new category position
//
// =============================================================================

package template_service

import (
	"context"
	"fmt"
	"time"

	"github.com/charmbracelet/bubbles/table"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/yogirk/tgcp/internal/core"
	"github.com/yogirk/tgcp/internal/ui/components"
)

const CacheTTL = 30 * time.Second

// =============================================================================
// Models
// =============================================================================

// ExampleItem represents a resource managed by this service
type ExampleItem struct {
	Name   string
	Status string
	ID     string
	Region string
}

// Tick message for background refresh
type tickMsg time.Time

// ViewState defines the current UI state of the service
type ViewState int

const (
	ViewList ViewState = iota
	ViewDetail
	ViewConfirmation
	// For services with tabs (e.g., Pub/Sub Topics/Subs, Cloud Run Services/Jobs):
	// ViewListPrimary   // e.g., Topics, Services
	// ViewListSecondary // e.g., Subscriptions, Jobs
)

// Message types for async operations
type dataMsg []ExampleItem
type errMsg error
type actionResultMsg struct {
	action string // "start", "stop", etc.
	name   string // resource name for toast
	err    error
}

// =============================================================================
// Service Definition
// =============================================================================

// Service implements the services.Service interface
type Service struct {
	client    *Client
	projectID string

	// Dimensions (for custom layouts)
	width  int
	height int

	// UI Components
	table         *components.StandardTable
	filter        components.FilterModel
	filterSession components.FilterSession[ExampleItem]
	spinner       components.SpinnerModel

	// Data State
	items   []ExampleItem
	err     error
	loaded  bool // Track if initial data has been loaded

	// View State
	viewState    ViewState
	selectedItem *ExampleItem

	// Confirmation State
	pendingAction string
	actionSource  ViewState

	// Cache
	cache *core.Cache
}

// Placeholder Client type - replace with actual GCP client
type Client struct{}

func NewClient(ctx context.Context) (*Client, error) {
	// Initialize your GCP client here
	// Example:
	// client, err := someapi.NewService(ctx)
	// if err != nil { return nil, err }
	return &Client{}, nil
}

// NewService creates a new instance of the service
func NewService(cache *core.Cache) *Service {
	columns := []table.Column{
		{Title: "Name", Width: 30},
		{Title: "Status", Width: 15},
		{Title: "Region", Width: 15},
		{Title: "ID", Width: 20},
	}

	t := components.NewStandardTable(columns)

	svc := &Service{
		table:     t,
		filter:    components.NewFilterWithPlaceholder("Filter items..."),
		spinner:   components.NewSpinner(),
		viewState: ViewList,
		cache:     cache,
		loaded:    false,
	}
	svc.filterSession = components.NewFilterSession(&svc.filter, svc.getFilteredItems, svc.updateTable)
	return svc
}

// Name returns the full human-readable name
func (s *Service) Name() string {
	return "Template Service"
}

// ShortName returns the identifier used for routing (e.g., "gce", "sql")
func (s *Service) ShortName() string {
	return "template"
}

// HelpText returns context-aware keybindings for the status bar
func (s *Service) HelpText() string {
	switch s.viewState {
	case ViewList:
		return "r:Refresh  /:Filter  Enter:Detail"
	case ViewDetail:
		return "s:Start  x:Stop  Esc/q:Back"
	case ViewConfirmation:
		return "y:Confirm  n:Cancel"
	default:
		return ""
	}
}

// =============================================================================
// Lifecycle & Interface Implementation
// =============================================================================

// InitService initializes the API client - called once when service is first accessed
func (s *Service) InitService(ctx context.Context, projectID string) error {
	s.projectID = projectID
	client, err := NewClient(ctx)
	if err != nil {
		return err
	}
	s.client = client
	return nil
}

// Reinit reinitializes the service with a new project ID (on project switch)
func (s *Service) Reinit(ctx context.Context, projectID string) error {
	s.Reset()
	s.loaded = false // Force reload on next entry
	return s.InitService(ctx, projectID)
}

// Init returns startup commands (background tick)
func (s *Service) Init() tea.Cmd {
	return s.tick()
}

// tick creates a background ticker for cache invalidation/refresh
func (s *Service) tick() tea.Cmd {
	return tea.Tick(CacheTTL, func(t time.Time) tea.Msg {
		return tickMsg(t)
	})
}

// Refresh triggers a forced data reload with spinner
func (s *Service) Refresh() tea.Cmd {
	return tea.Batch(
		s.spinner.Start(""), // Empty string = playful random messages
		s.fetchDataCmd(true),
	)
}

// Reset clears the service state when navigating away
func (s *Service) Reset() {
	s.viewState = ViewList
	s.selectedItem = nil
	s.err = nil // CRITICAL: Always clear errors on reset
	s.pendingAction = ""
	s.table.SetCursor(0)
	s.filter.ExitFilterMode()
}

// IsRootView returns true if at the top-level list (used for 'q' navigation)
func (s *Service) IsRootView() bool {
	return s.viewState == ViewList
}

// Focus handles input focus - triggers initial load if needed
func (s *Service) Focus() {
	s.table.Focus()
}

// Blur handles loss of input focus
func (s *Service) Blur() {
	s.table.Blur()
}

// =============================================================================
// Update Loop
// =============================================================================

func (s *Service) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	// -------------------------------------------------------------------------
	// SPINNER ANIMATION - Must be first for smooth animation
	// -------------------------------------------------------------------------
	case components.SpinnerTickMsg:
		s.spinner, cmd = s.spinner.Update(msg)
		return s, cmd

	// -------------------------------------------------------------------------
	// BACKGROUND TICK - Cache refresh
	// -------------------------------------------------------------------------
	case tickMsg:
		return s, tea.Batch(s.fetchDataCmd(false), s.tick())

	// -------------------------------------------------------------------------
	// DATA LOADED
	// -------------------------------------------------------------------------
	case dataMsg:
		s.spinner.Stop()
		s.items = msg
		s.loaded = true
		s.filterSession.Apply(s.items)
		return s, func() tea.Msg { return core.LastUpdatedMsg(time.Now()) }

	// -------------------------------------------------------------------------
	// ERROR HANDLING
	// -------------------------------------------------------------------------
	case errMsg:
		s.spinner.Stop()
		s.err = msg
		return s, nil

	// -------------------------------------------------------------------------
	// ACTION RESULT - Show toast notification
	// -------------------------------------------------------------------------
	case actionResultMsg:
		s.spinner.Stop()
		if msg.err != nil {
			return s, func() tea.Msg {
				return core.ToastMsg{
					Message: fmt.Sprintf("Failed to %s %s: %v", msg.action, msg.name, msg.err),
					Type:    core.ToastError,
				}
			}
		}
		// Success - show toast and refresh
		return s, tea.Batch(
			func() tea.Msg {
				return core.ToastMsg{
					Message: fmt.Sprintf("%s %s successfully", capitalize(msg.action), msg.name),
					Type:    core.ToastSuccess,
				}
			},
			s.Refresh(),
		)

	// -------------------------------------------------------------------------
	// WINDOW RESIZE
	// -------------------------------------------------------------------------
	case tea.WindowSizeMsg:
		s.width = msg.Width
		s.height = msg.Height
		s.table.HandleWindowSizeDefault(msg)

	// -------------------------------------------------------------------------
	// MOUSE INPUT - Forward to table for click selection
	// -------------------------------------------------------------------------
	case tea.MouseMsg:
		if s.viewState == ViewList {
			var updatedTable *components.StandardTable
			updatedTable, cmd = s.table.Update(msg)
			s.table = updatedTable
			return s, cmd
		}

	// -------------------------------------------------------------------------
	// USER INPUT
	// -------------------------------------------------------------------------
	case tea.KeyMsg:
		return s.handleKeyMsg(msg)
	}

	return s, nil
}

// handleKeyMsg processes keyboard input based on current view state
func (s *Service) handleKeyMsg(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	// -------------------------------------------------------------------------
	// LIST VIEW
	// -------------------------------------------------------------------------
	if s.viewState == ViewList {
		// Filter handling (must be first)
		result := s.filterSession.HandleKey(msg)
		if result.Handled {
			if result.Cmd != nil {
				return s, result.Cmd
			}
			if !result.ShouldContinue {
				return s, nil
			}
		}

		switch msg.String() {
		case "r":
			return s, s.Refresh()
		case "enter":
			items := s.getCurrentItems()
			if idx := s.table.Cursor(); idx >= 0 && idx < len(items) {
				s.selectedItem = &items[idx]
				s.viewState = ViewDetail
			}
			return s, nil

		// For services with tabs, add tab switching:
		// case "tab", "[", "]":
		//     if s.viewState == ViewListPrimary {
		//         s.viewState = ViewListSecondary
		//         s.secondaryFilterSession.Apply(s.secondaryItems)
		//     } else {
		//         s.viewState = ViewListPrimary
		//         s.filterSession.Apply(s.items)
		//     }
		//     return s, nil
		}

		// Pass to table for navigation (j/k, up/down)
		var updatedTable *components.StandardTable
		updatedTable, cmd = s.table.Update(msg)
		s.table = updatedTable
		return s, cmd
	}

	// -------------------------------------------------------------------------
	// DETAIL VIEW
	// -------------------------------------------------------------------------
	if s.viewState == ViewDetail {
		switch msg.String() {
		case "esc", "q":
			s.viewState = ViewList
			s.selectedItem = nil
			return s, nil
		case "s": // Start action
			s.pendingAction = "start"
			s.actionSource = ViewDetail
			s.viewState = ViewConfirmation
			return s, nil
		case "x": // Stop action
			s.pendingAction = "stop"
			s.actionSource = ViewDetail
			s.viewState = ViewConfirmation
			return s, nil
		}
	}

	// -------------------------------------------------------------------------
	// CONFIRMATION VIEW
	// -------------------------------------------------------------------------
	if s.viewState == ViewConfirmation {
		switch msg.String() {
		case "y", "enter":
			action := s.pendingAction
			s.viewState = s.actionSource
			s.pendingAction = ""
			return s, s.performActionCmd(action)
		case "n", "esc", "q":
			s.viewState = s.actionSource
			s.pendingAction = ""
			return s, nil
		}
	}

	return s, nil
}

// =============================================================================
// View Rendering
// =============================================================================

func (s *Service) View() string {
	// Error state
	if s.err != nil {
		return components.RenderError(s.err, s.Name(), "Items")
	}

	// Loading state (spinner)
	if s.spinner.IsActive() {
		return s.spinner.View()
	}

	// Confirmation dialog
	if s.viewState == ViewConfirmation && s.selectedItem != nil {
		return components.RenderConfirmation(s.pendingAction, s.selectedItem.Name, "item")
	}

	// Detail view
	if s.viewState == ViewDetail {
		return s.renderDetailView()
	}

	// Default: List view
	return s.renderListView()
}

func (s *Service) renderListView() string {
	breadcrumb := components.Breadcrumb(
		fmt.Sprintf("Project: %s", s.projectID),
		s.Name(),
	)

	// For services with tabs, show tab indicator:
	// tabIndicator := s.renderTabBar() // "[Topics] Subscriptions" or "Topics [Subscriptions]"

	return lipgloss.JoinVertical(lipgloss.Left,
		breadcrumb,
		s.filter.View(),
		s.table.View(),
	)
}

func (s *Service) renderDetailView() string {
	if s.selectedItem == nil {
		return "Error: No item selected"
	}

	breadcrumb := components.Breadcrumb(
		fmt.Sprintf("Project: %s", s.projectID),
		s.Name(),
		s.selectedItem.Name,
	)

	// DetailCard with auto-status detection
	// Fields named "Status" or "State" are automatically rendered as badges
	card := components.DetailCard(components.DetailCardOpts{
		Title: "Item Details",
		Rows: []components.KeyValue{
			{Key: "Name", Value: s.selectedItem.Name},
			{Key: "Status", Value: s.selectedItem.Status}, // Auto-styled as badge
			{Key: "Region", Value: s.selectedItem.Region},
			{Key: "ID", Value: s.selectedItem.ID},
		},
	})

	// Footer hints with consistent styling
	actions := components.RenderFooterHint("s Start | x Stop | q Back")

	return lipgloss.JoinVertical(lipgloss.Left,
		breadcrumb,
		"",
		card,
		"",
		actions,
	)
}

// =============================================================================
// Data Fetching
// =============================================================================

func (s *Service) fetchDataCmd(force bool) tea.Cmd {
	return func() tea.Msg {
		cacheKey := fmt.Sprintf("template_items:%s", s.projectID)

		// Check cache first (unless forced refresh)
		if !force && s.cache != nil {
			if val, found := s.cache.Get(cacheKey); found {
				if items, ok := val.([]ExampleItem); ok {
					return dataMsg(items)
				}
			}
		}

		// API call
		if s.client == nil {
			return errMsg(fmt.Errorf("client not initialized"))
		}

		// Replace with actual API call:
		// items, err := s.client.ListItems(s.projectID)
		// if err != nil {
		//     return errMsg(err)
		// }
		items := []ExampleItem{} // Placeholder

		// Update cache
		if s.cache != nil {
			s.cache.Set(cacheKey, items, CacheTTL)
		}

		return dataMsg(items)
	}
}

// =============================================================================
// Table Updates
// =============================================================================

func (s *Service) updateTable(items []ExampleItem) {
	rows := make([]table.Row, len(items))
	for i, item := range items {
		rows[i] = table.Row{
			item.Name,
			components.RenderStatus(item.Status), // Status badge styling
			item.Region,
			item.ID,
		}
	}
	s.table.SetRows(rows)
}

// getCurrentItems returns items with current filter applied
func (s *Service) getCurrentItems() []ExampleItem {
	return s.getFilteredItems(s.items, s.filter.Value())
}

// getFilteredItems filters items based on query string
func (s *Service) getFilteredItems(items []ExampleItem, query string) []ExampleItem {
	if query == "" {
		return items
	}
	return components.FilterSlice(items, query, func(item ExampleItem, q string) bool {
		return components.ContainsMatch(item.Name, item.Status, item.Region, item.ID)(q)
	})
}

// =============================================================================
// Actions
// =============================================================================

func (s *Service) performActionCmd(action string) tea.Cmd {
	item := s.selectedItem
	if item == nil {
		return nil
	}

	return func() tea.Msg {
		if s.client == nil {
			return actionResultMsg{action: action, name: item.Name, err: fmt.Errorf("client not initialized")}
		}

		var err error
		switch action {
		case "start":
			// err = s.client.StartItem(s.projectID, item.ID)
		case "stop":
			// err = s.client.StopItem(s.projectID, item.ID)
		default:
			err = fmt.Errorf("unknown action: %s", action)
		}

		return actionResultMsg{action: action, name: item.Name, err: err}
	}
}

// =============================================================================
// Helpers
// =============================================================================

func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}
	return string(s[0]-32) + s[1:] // Simple ASCII capitalize
}

// =============================================================================
// TABS PATTERN (Optional - for services with multiple resource types)
// =============================================================================
//
// For services like Pub/Sub (Topics/Subscriptions) or Cloud Run (Services/Jobs),
// add a second set of items and filter session:
//
// type Service struct {
//     // ... existing fields ...
//
//     // Secondary items (e.g., Subscriptions, Jobs)
//     secondaryItems         []SecondaryItem
//     secondaryFilterSession components.FilterSession[SecondaryItem]
// }
//
// Then in Update, handle tab switching:
//
// case "tab", "[", "]":
//     if s.viewState == ViewListPrimary {
//         s.viewState = ViewListSecondary
//         s.updateSecondaryTable(s.secondaryItems)
//     } else {
//         s.viewState = ViewListPrimary
//         s.updateTable(s.items)
//     }
//
// In HelpText, show which tab is active:
//
// case ViewListPrimary:
//     return "Tab:Switch to Subs  r:Refresh  /:Filter"
// case ViewListSecondary:
//     return "Tab:Switch to Topics  r:Refresh  /:Filter"
//
// =============================================================================
